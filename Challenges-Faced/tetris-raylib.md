# Tetris - 21/11/2023

### Description

Tetris is a very simple game, yet, I can't help overthinking its implementation details. As most of you have experienced, taking on a new projects mostly ensues endless procrastination, I suppose as related to the imposter syndrome comments I made in the description of [pong-raylib](https://github.com/AlOwain-LearningGraphics/docs/blob/main/Challenges-Faced/pong-raylib.md#Description) I believe there is a co-relation between the motivation behind procrastination and in the reasons behind feeling an Imposter Syndrome. I suppose there are multiple factors behind procrastination, but one commonly felt by programmers is the fear of facing your lack of mental abilities. I believe in the vast majority of cases the fear is unfound and unreasonable, as most fear is. Fear should not exist, yet it does, lest those that lack reasonability act without restrain. Reason alone should motivate you, an important note would be how unpolished those thoughts are, I haven't reflected on them enough, there is a very likely chance I'd want to take back what I said here, but regardless, reason has served me well in motivating me to undertake the necessary but difficult paths to achieve my goals, yet reason is a weak but lasting motivator just as habits are, you never feel compelled to go through the same habits daily, yet you do for years on-end; emotions only motivate you temporarily sometimes compelling you to do something that will immensely harm you and others, yet you couldn't do something "because you want to" for more than 2 months.

### The challenges

At first I didn't know where to start, which is a recurring theme in programming generally. After starting to work the first challenge I faced was the implementation of a grid, overthinking minute details such as performance and maintainability hinder your ability to write good code. Good code is not written by overthinking, but by slow and timely progress and learning pattern matching through experience, good code is simple code and simple being the antonym of complicated, makes complicated and messy thoughts oppose good code. Good code is beautiful in its application, efficient and not overly-descriptive, with form and function. However, as every programmer does I started by overthinking it.

When thinking of an accurate data structure to describe the grid I went through many different thoughts, I started by considering an array of arrays, but had you completed any rows you would have to move every single item in the first array, now our phones are super-computers in comparison to the devices that ran Tetris originally, and performance isn't even a consideration in such an application, but I chose not to, either out of a desire to write consice and smart code or out of worry that dumbing down my code will make it harder to maintain my code later on. I began overthinking it even more, I started thinking about the tetris grid as -technically- a stack of blocks. So I started working on implementing that, now what if I create a stack of rows, basically adding row above row; well, in reality, Tetris is more complicated. Tetris allows you to fill a column while all other rows are empty, Tetris allows you to place blocks without something filling everything under them. I haven't found any way to apply a stack to create a grid, I have tried to seperate the grid into seperate stacks per column, but then what happens if you add a Tetrominio to column #2 when column #1 or column #3 already have Tetrominioes filling the neighboring squares. And after hours of implementing and thinking about solutions; as one does, I have returned back to "dumbing down" my code and simply using an array of arrays.. (for now)

I read this quote by Brian Kernighan: “Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.”, there seems to be a lot to take from that, but I'd suggest that one very important note you should have is to always write code that is simple enough for you to grasp wholly. It's really important to make sure your code is simple and easy to grasp, as the relationship between the code's difficulty when writing it initially and in maintance is exponential.

#### Building a Tetrominio

When you look at a Tetris game, you find that its seperated into Tetrominoes, a Tetromino consists of four different blocks, well how do you accurately represent it as an object, how do you draw them, and how is its physics and collisions calculated? I chose to draw a Tetromino by going through an array of Tetrominioes in the main class, every member in that array has a draw function. In it the Tetromino will follow some rules to draw itself, those rules are made in its construction, the rules are to draw a block in its initial position, then move either (UP, RIGHT, DOWN, or LEFT). Now the draw function will draw a block 40 pixels tall and 40 pixels wide, then move on to the next instruction on the direction it should go. This and most other data structures have limitations, one very obvious one is that you must follow a direction, you can't draw objects that seperate into two different branches. You can hack that by going a certain branch then stepping back and going to the other branch; which is unnecessary computation; but I'm making tetris, a game that wouldn't account for 1% of what modern games render.

#### Moving a Tetromino

We often rely more than we should on assumptions in programming; all bugs are assumptions that do not reflect accurately the state of the program. A Tetromino piece falls ~1 block/second. Now how do you make it fall? It's quite easy to make it go down, but how do you make it go down and stop? Well I suppose we use our collision detection system to go through our Tetrominoes' instructions, determine the positions it will occupy, and check each position for any previously placed blocks. When it encounters any already filled spots, it must then stop any further movement of the Tetromino. I suppose we've all played Tetris, it's the worlds most sold game! Well then we all know that if a certain row were filled that row is removed, and every piece above it falls down; so, should we actively check each Tetromino for any collision under it? What I ended up doing is a __focus__ system, where only certain Tetrominoes are focused to trigger an update to their logical cycle, hence the lifetime of a Teromino includes being spawned and focused on till you collide with the ground, then you are put out of focus, another Tetromino is focused and now your logic cycle no longer executes since you are out of focus, when a row is filled you are put back into focus, which makes it that we don't have to compute your logic cycle when we know there hasn't been a change under you (less computation). Well then that's one challenge set, we can detect when to stop when colliding with other blocks, and we can communicate the nullification of that collision, So I set out on implementing that system, but quickly I faced a totally unexpected situation, when moving 1 block down, the Tetromino collision system goes through each piece of the Tetromino in its new position trying to see if there would be a collision under it, now what I noticed is for some reason it kept detecting a collision when there isn't even any Tetromino on the grid but itself! I quickly realized that it sees some block occupying that position, but it doesn't realize that it itself is the one occupying (a part) of that new position: for an example, suppose a 2 by 2 square Tetromino occupies the coordinates (x=5,6 and y=20,19) when it goes down one block its level will turn to (y=19,18) and its x unchanged, well both its previous position and new position occupy (x=5,6 and y=19) so it simply thinks a collision is there and stops. At this point the movement of the Tetrominoes and their represention using coordinates was causing me nightmares, all with the thought of the challenge of rotating them looming over me; after all, it's the reason I chose to represent Tetrominoes as a set of instructions rather than a coordinate map on a 4 by 4 grid, representing them as a set of instructions will make rotating them simple changing the direction you go and it would work for every piece. Representing them as a grid would have erased every challenge I've had, but is it worth it when comparing it to writing some complex method of rotating them that I even avoid thinking about. By now I am simply unsure of whether I am missing some really clever trick that represents a Tetromino as it is without having to use instructions or a grid; surely there is a smarter way to do this, but oh well, the ship has long sailed on rewriting all of this.

#### Seperating the drawing of the grid and the Tetromino

You naturally come to the conclusion of seperating the grid into blocks for each grid position, instead of the previous system I had implemented which seperated it into tetrominoes; it is just vastly simpler. Keeping the main movable Tetromino on its own is really important as the calculation of its movement is reliant on its other blocks. You could just have a grid that moves 4 seperate pieces, but then rotating them would be real challenge.

#### Filling a row

When a row in the main grid is filled, it is removed and all rows above it go down a level, this is very easy to grasp, but it's implementation gets more complicated the more you advance the deletion of the row. As I said previously (see issue#5) you could just loop through all the arrays in the grid[][] and move every single item one level below, but seeking simplicity I thought I could display the grid[][] according to a drawing order, and instead of actually moving every single item in the grid[][] I thought I should just change the drawing order. Working through this I realized that possibly a better solution would just to make the grid[][] an array of pointers to arrays. (I will continue documentation after I experiment with that..)
