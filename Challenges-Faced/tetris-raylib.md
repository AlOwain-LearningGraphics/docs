# Tetris - 21/11/2023

### Description

Tetris is a very simple game, yet, I can't help overthinking its implementation details. As most of you have experienced, taking on a new projects mostly ensues endless procrastination, I suppose as related to the imposter syndrome comments I made in the description of (pong-raylib)[https://github.com/AlOwain-LearningGraphics/docs/blob/main/Challenges-Faced/pong-raylib.md#Description] I believe there is a co-relation between the motivation behind procrastination and in the reasons behind feeling an Imposter Syndrome. I suppose there are multiple factors behind procrastination, but one commonly felt by programmers is the fear of facing your lack of mental abilities. I believe in the vast majority of cases the fear is unfound and unreasonable, as most fear is. Fear should not exist, yet it does, lest those that lack reasonability act without restrain. Reason alone should motivate you, an important note would be how unpolished those thoughts are, I haven't reflected on them enough, there is a very likely chance I'd want to take back what I said here, but regardless, reason has served me well in motivating me to undertake the necessary but difficult paths to achieve my goals, yet reason is a weak but lasting motivator just as habits are, you never feel compelled to go through the same habits daily, yet you do for years on-end; emotions only motivate you temporarily sometimes compelling you to do something that will immensely harm you and others, yet you couldn't do something "because you want to" for more than 2 months.

### The challenges

At first I didn't know where to start, which is a recurring theme in programming generally. After starting to work the first challenge I faced was the implementation of a grid, overthinking minute details such as performance and maintainability hinder your ability to write good code. Good code is not written by overthinking, but by slow and timely progress and learning pattern matching through experience, good code is simple code and simple being the antonym of complicated, makes complicated and messy thoughts oppose good code. Good code is beautiful in its application, efficient and not overly-descriptive, with form and function. However, as every programmer does I started by overthinking it.

When thinking of an accurate data structure to describe the grid I went through many different thoughts, I started by considering an array of arrays, but had you completed any rows you would have to move every single item in the first array, now our phones are super-computers in comparison to the devices that ran Tetris originally, and performance isn't even a consideration in such an application, but I chose not to, either out of a desire to write consice and smart code or out of worry that dumbing down my code will make it harder to maintain my code later on. I began overthinking it even more, I started thinking about the tetris grid as -technically- a stack of blocks. So I started working on implementing that, now what if I create a stack of rows, basically adding row above row; well, in reality, Tetris is more complicated. Tetris allows you to fill a column while all other rows are empty, Tetris allows you to place blocks without something filling everything under them. I haven't found any way to apply a stack to create a grid, I have tried to seperate the grid into seperate stacks per column, but then what happens if you add a Tetrominio to column #2 when column #1 or column #3 already have Tetrominioes filling the neighboring squares. And after hours of implementing and thinking about solutions; as one does, I have returned back to "dumbing down" my code and simply using an array of arrays.. (for now)

I read this quote by Brian Kernighan: “Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.”, there seems to be a lot to take from that, but I'd suggest that one very important note you should have is to always write code that is simple enough for you to grasp wholly. It's really important to make sure your code is simple and easy to grasp, as the relationship between the code's difficulty when writing it initially and in maintance is exponential.

#### Building a Tetrominio

When you look at a Tetris game, you find that its seperated into Tetrominoes, a Tetromino consists of four different blocks, well how do you accurately represent it as an object, how do you draw them, and how is its physics and collisions calculated? I chose to draw a Tetromino by going through an array of Tetrominioes in the main class, every member in that array has a draw function. In it the Tetromino will follow some rules to draw itself, those rules are made in its construction, the rules are to draw a block in its initial position, then move either (UP, RIGHT, DOWN, or LEFT). Now the draw function will draw a block 40 pixels tall and 40 pixels wide, then move on to the next instruction on the direction it should go. This and most other data structures have limitations, one very obvious one is that you must follow a direction, you can't draw objects that seperate into two different branches. You can hack that by going a certain branch then stepping back and going to the other branch; which is unnecessary computation; but I'm making tetris, a game that wouldn't account for 1% of what modern games render.
